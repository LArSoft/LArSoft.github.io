
{{toc}}

h1. Package Documentation

This is the complete list of packages.  Each has a short description, and each has a link to the package&#39;s full documentation.

* *Developers:* when you add a package to the LArSoft build, *document it* here!  Follow the examples, or start with the wiki source from this [[YourPackageName|template documentation page]].

Some definitions:
# A *package* is a collection of related code under a single directory in the LArSoft offline release.
# A *module* is the named item that performs an algorithm and makes up an element of your job.  A job is a sequence of modules.

A *package* usually provides any number of *modules* that performs similar tasks, ie hit finding, but some packages provide no modules (_e.g._, @Utilities@) and some provide multiple modules (_e.g._, @ClusterFinder@). A *package* is a code organizational unit, and a *module* is a runtime (job sequence) unit.

*Categories*.  The categories below give a general sense of what sort of services each package provides.
* *Reconstruction*: modules for event reconstruction, please see the [[RecoBase]] page for an overview of the reconstruction
* *Simulation*: modules for the simulation chain, please see the [[Simulation]] page for an overview of the simulation
* *Utility*: no run time modules; provides services, classes or methods that are used by other packages

h2. LArSoft Packages

This is a (still-evolving) description of the packages within the LArSoft "distribution" that are unique to LArSoft. 

The source code for all packages can be browsed using "Doxygen":http://nusoft.fnal.gov/larsoft/doxsvn/html/index.html. 

For convenience, there&#39;s a list of which namespace corresponds to which package in the table below.

|_.Package|_.Namespace|_.Category|_.Short description|
|[[RecoBase]]|@recob::@|Reconstruction|Classes for reconstruction objects (Wires, Hits, Clusters, ...)|
|[[AnalysisBase]]|@anab::@|Reconstruction|Classes for final-stage reconstruction physics objects (particles, shower energy, ...)|
|[[CalData]]|@caldata::@|Reconstruction|Applies basic channel-level calibrations, turning RawDigits into Wires|
|[[Calorimetry]]|@calo::@|Reconstruction|Calorimetric reconstruction of 3D tracks|
|[[ClusterFinder]]|@cluster::@|Reconstruction|Groups hits into collections that are correlated in space and time|
|[[EventFinder]]|@event::@|Reconstruction|Group Vertex objects into reconstructed Event objects|
|[[HitFinder]]|@hit::@|Reconstruction|Localizes energy deposition in time on each channel|
|[[ShowerFinder]]|@shwf::@|Reconstruction|Build showers out of clusters|
|[[TrackFinder]]|@trkf::@|Reconstruction|Build tracks out of clusters|
|[[VertexFinder]]|@vertex::@|Reconstruction|Identify vertices|
|[[Simulation]]|@sim::@|Simulation|Classes related to the simulation|
|[[EventGenerator]]|@evgen::@|Simulation|The primary interface to all event generation routines (GENIE, CRY, single particle)|
|[[DetSim]]|@detsim::@|Simulation|Simulates the electronics response of a TPC|
|[[LArG4]]|@larg4::@|Simulation|Geant4 interface classes|
|[[PhotonProgatation]]|@phot::@|Simulation|Creates a library for fast simulation of optical photons in [[LArG4]]|
|[[OpticalDetector]]|@opdet::@|Simulation|Algorithms for simulating the operation of the ADCs and FEMs associated with the PMTs|
|[[OpticalDetectorData]]|@optdata::@|Simulation|Data classes for passing event information between the OpticalDetector modules|
|[[Backtracking the simulation|MCCheater]]|@cheat::@|Simulation|Classes for producing perfect reconstruction and associating reconstruction to MC truth|
|[[EventDisplay]]|@evd::@|Utility|The event display |
|[[Filters]]|@filt::@|Utility|User-defined filters for culling un-desired events from your job/output|
|[[Geometry]]|@geo::@|Utility|Provides Geometry service that knows all about the LAr geometries|
|[[RawData]]|@raw::@|Utility|Classes relating to raw data storage|
|[[Utilities]]|@util::@|Utility|Includes code to do FFT on RawData, find LAr parameters, etc|
|[[_AnalysisExample_|AnalysisExample]]|@lar::example@|Instructional|Start here for LArSoft coding basics|


h2. Other packages

LArSoft depends on several other packages. The list below is not exhaustive; it focuses on packages and namespaces that are most likely to be seen in LArSoft source code. 

h3. nutools

"nutools":https://cdcvs.fnal.gov/redmine/projects/nusoft/repository/show/nutools are packages shared by LArSoft and other neutrino experiments at Fermilab, including "nova":http://www-nova.fnal.gov/ and "mu2e":http://mu2e.fnal.gov/. The header files can be found in @$NUTOOLS_INC@.

|_.Package|_.Namespace|_.Short description|
|EventDisplayBase|@evdb::@|Common tools and widgets for the event display|
|EventGeneratorBase|@evgb::@|Common tools for the event generator, including "GENIE":http://www.genie-mc.org/.|
|SimulationBase|@simb::@|Base classes for truth and simulated particles|
|G4Base|@g4b::@|Common classes for Geant4 simulation|

h3. ART

"ART":https://cdcvs.fnal.gov/redmine/projects/art/wiki is the software framework used by LArSoft. It&#39;s maintained by the Fermilab computing division. 

|_.Package|_.Namespace|_.Short description|_.Location of headers|
|ART|@art::@|Framework classes that handle I/O|@$ART_INC/art@|
|"cetlib":https://cdcvs.fnal.gov/redmine/projects/cetlib/wiki|@cetlib::@|Utility programming components, e.g., pointers and memory management|@$CETLIB_INC/cetlib@|
|"FHICL":https://cdcvs.fnal.gov/redmine/projects/fhicl/documents|@fhicl::@|Fermilab Hierarchical Configuration Language, used to configure jobs|@$FHICLCPP_INC/fhiclcpp@|
|"messagefacility":https://cdcvs.fnal.gov/redmine/projects/messagefacility/wiki/Tutorial_for_MessageFacility_v12_Configuration|@mf::@|Controls the display of messages as a job runs|@$MESSAGEFACILITY_INC/messagefacility@|

h3. Pandora

The [[Pandora]] Software Development Kit provides a set of pattern recognition algorithms for use in LAr neutrino detectors.
Work is currently in progress to integrate these into the LArSoft framework.

h3. External packages

These are package written and maintained by the general physics and computing communities. 

|_.Package|_.Namespace|_.Short description|_.Location of headers|
|"C++":http://www.cplusplus.com/reference/|@std::@|\2. Extensions to base C++ that are part of the standard language|
|"ROOT":https://root.cern.ch|See below|Data-analysis tools|@$ROOT_INC@|
|"CLHEP":http://proj-clhep.web.cern.ch/proj-clhep/|@CLHEP::@|Class Library for High-Energy Physics|@$CLHEP_INC/CLHEP@|
|"Geant4":http://geant4.web.cern.ch/geant4/|See below|Detector simulations|@$G4INCLUDE@|
|"GENIE":http://www.genie-mc.org/|@genie::@|Neutrino Monte-Carlo Generator|@$GENIE_INC/GENIE@|
|"boost":http://www.boost.org/|@boost::@|General programming tools for C++|@$BOOST_INC/boost@|

ROOT and Geant4 do not use namespaces. In general, ROOT classes begin with "T" (e.g., "TTree":http://root.cern.ch/root/html522/TTree.html, "TH1":http://root.cern.ch/root/html522/TH1.html) while "Geant4 classes":http://geant4www.triumf.ca/lxr/ begin with "G4" (e.g., "G4Track":http://geant4www.triumf.ca/lxr/source//track/include/G4Track.hh, "G4Step":http://geant4www.triumf.ca/lxr/source//track/include/G4Step.hh). Exception: Some of the newer ROOT sub-packages have namespaces (such as @ROOT::Math::@, @ROOT::Fit::@, @ROOT::Minuit2::@, @Reflex::@, @TMVA::@).

Some of these packages duplicate functionality; e.g., 4-vectors are implemented in both "ROOT":http://root.cern.ch/root/html522/TLorentzVector.html and "CLHEP":http://proj-clhep.web.cern.ch/proj-clhep/doc/CLHEP_2_1_2_2/doxygen/html/LorentzVector_8h.html. Given a choice, use a package that&#39;s higher in the above tables over one that&#39;s lower; e.g., choose ROOT classes over their CLHEP equivalents. 

h2. Units

To establish some standard, especially for values stored in ROOT files and N-tuples:

    * distances are in centimeters (cm);
    * energies are in GeV;
    * time is in nanoseconds (ns);
    * masses are in grams (g).
